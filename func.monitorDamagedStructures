var monitorDamagedStructures = {
    
    run: function(curRoom) {
        
        if (!curRoom.memory.structuresAtRisk) curRoom.memory.structuresAtRisk = [];
        
        var damagedStructures = curRoom.find(FIND_STRUCTURES, (schematic) => schematic.hits <= (schematic.hitsMax * 0.25) || schematic.hits <= (100));
        
        for (var a in damagedStructures) {
            var curStructure = {x: damagedStructures[a].pos.x, y: damagedStructures[a].pos.y, type: damagedStructures[a].structureType};
            if (curRoom.memory.structuresAtRisk.length) {
                var isDupe = false;
                uniqueCheck:
                for (var b in curRoom.memory.structuresAtRisk) {
                    if (curStructure.x === curRoom.memory.structuresAtRisk[b].x && curStructure.y === curRoom.memory.structuresAtRisk[b].y && curStructure.type === curRoom.memory.structuresAtRisk[b].type) {
                        isDupe = true;
                        break uniqueCheck;
                    }
                }
                if (!isDupe) {
                    curRoom.memory.structuresAtRisk.push({x: curStructure.x, y: curStructure.y, type: curStructure.type});
                }
            }
            else {
                curRoom.memory.structuresAtRisk.push({x: curStructure.x, y: curStructure.y, type: curStructure.type});
            }
        }
        
        // Function to work through the structures that may be destroyed
        if (!(Game.time % 5)) {
            if (curRoom.memory.structuresAtRisk.length) {
                for (var a in curRoom.memory.structuresAtRisk) {
                    var curTile = curRoom.lookAt(curRoom.memory.structuresAtRisk[a].x, curRoom.memory.structuresAtRisk[a].y);
                    var isDestroyed = true;
                    var isQueued = false;
                    tileChecker:
                    for (var b in curTile) {
                        if (curTile[b].type === 'structure' && curTile[b].structure.structureType === curRoom.memory.structuresAtRisk[a].type) {
                            if (curTile[b].structure.hits >= (curTile[b].structure.hitsMax * 0.25)) {
                                curRoom.memory.structuresAtRisk.splice(a, 1);
                                isDestroyed = false;
                                break tileChecker;
                            }
                        }
                        else if (curTile[b].type === 'constructionSite' && curTile[b].constructionSite.structureType === curRoom.memory.structuresAtRisk[a].type) {
                            isDestroyed = false;
                            break tileChecker;
                        }
                    }
                    dupeChecker:
                    for (var b in curRoom.memory.buildQueue) {
                        if (curRoom.memory.buildQueue[b].x == curRoom.memory.structuresAtRisk[a].x && curRoom.memory.buildQueue[b].y == curRoom.memory.structuresAtRisk[a].y && curRoom.memory.buildQueue[b].type == curRoom.memory.structuresAtRisk[a].type) {
                            isQueued = true;
                            break dupeChecker;
                        }
                    }
                    if (isDestroyed && !isQueued) {
                        queueBuild(curRoom.memory.structuresAtRisk[a].x, curRoom.memory.structuresAtRisk[a].y, curRoom.memory.structuresAtRisk[a].type);
                    }
                }
            }
        }
        
    }
}

module.exports = monitorDamagedStructures;
