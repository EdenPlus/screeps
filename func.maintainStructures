var maintainStructures = {
    
    run: function(curRoom) {
        if (!curRoom.memory.repairSites) curRoom.memory.repairSites = [];
        if (!curRoom.memory.sourceRoad) curRoom.memory.sourceRoad = [];
        if (!curRoom.memory.buildQueue) curRoom.memory.buildQueue = [];
        
        const MAXSITES = 3;
        
        var allStructuresInRoom = curRoom.find(FIND_STRUCTURES);
        
        var spawns = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_SPAWN);
        var extensions = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_EXTENSION);
        var containers = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_CONTAINER);
        
        var sources = curRoom.find(FIND_SOURCES);
        
        var constructionSites = curRoom.find(FIND_CONSTRUCTION_SITES);
        var sites = constructionSites.length;
        
        var allCreepsInRoom = curRoom.find(FIND_MY_CREEPS);
        
        var numFighters = _.filter(allCreepsInRoom, (creep) => creep.memory.role == 'fighter').length;
        var numHealers = _.filter(allCreepsInRoom, (creep) => creep.memory.role == 'healer').length;
        var numTowers = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_TOWER).length;
        
        if (!(Game.time % 100) && !sites) {
             var repairSites = _.filter(allStructuresInRoom, (structure) => {
                    if (curRoom.find(FIND_HOSTILE_CREEPS).length) {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART);
                    } else {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART); //  Fix anything below %
                    }
                });
            curRoom.memory.repairSites = [];
            for (let i in repairSites) {
                curRoom.memory.repairSites[i] = repairSites[i].id;
            }
        }
        
        // Function to add new construction sites to a list for building
        function queueBuild(x, y, type) {
            if (!curRoom.memory.buildQueue) curRoom.memory.buildQueue = [];
            for (let i in curRoom.memory.buildQueue) {
                if (x == curRoom.memory.buildQueue[i].x && y == curRoom.memory.buildQueue[i].y) {
                    return -1;
                }
            }
            if ((!curRoom.lookForAt(LOOK_STRUCTURES,x,y)[0]) || type == STRUCTURE_RAMPART || type == STRUCTURE_ROAD) {
                curRoom.memory.buildQueue.push({x:x,y:y,type:type});
            }
        }
        
        // Queues up construction for a path
        function buildRoad(path, end) {
            for (let i in path) {
                if (i < (path.length - 2)) {
                    queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
                } else {
                    queueBuild(path[i].x,path[i].y, end);
                }
            }
        }
        
        // Build road around controller
        function buildControllerRoad() {
            var path = curRoom.findPath(spawns[0].pos,curRoom.controller.pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => (schematic.type == STRUCTURE_SPAWN || schematic.type == STRUCTURE_WALL || schematic.type == STRUCTURE_EXTENSION || schematic.type == STRUCTURE_LINK || schematic.type == STRUCTURE_STORAGE || schematic.type == STRUCTURE_TOWER || schematic.type == STRUCTURE_OBSERVER || schematic.type == STRUCTURE_POWER_SPAWN || schematic.type == STRUCTURE_LAB || schematic.type == STRUCTURE_TERMINAL || schematic.type == STRUCTURE_NUKER));
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }});
            for (let i = 0; i < (path.length - 5); i++) {
                queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(curRoom.controller.pos.x + i, curRoom.controller.pos.y + 4, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(curRoom.controller.pos.x - 4, curRoom.controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(curRoom.controller.pos.x + 4, curRoom.controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(curRoom.controller.pos.x + i, curRoom.controller.pos.y - 4, STRUCTURE_ROAD);
            }
        }
        
        // Function to visualize the planQueue
        function visualizeBlueprint(curRoomName, structType, x, y) {
            var rads = 0.55;
            switch (structType) {
                case 0:
                    // Road: #bdbdbd
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#bdbdbd', radius: rads, stroke: '#bdbdbd'});
                    break;
                case 1:
                    // Extension: #ffed1c
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#ffed1c', radius: rads, stroke: '#ffed1c'});
                    break;
                case 2:
                    // Tower: #ff1697
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#ff1697', radius: rads, stroke: '#ff1697'});
                    break;
                case 3:
                    // Spawn: #b135ff
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#b135ff', radius: rads, stroke: '#b135ff'});
                    break;
                case 4:
                    // Power Spawn: #ff0000
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#ff0000', radius: rads, stroke: '#ff0000'});
                    break;
                case 5:
                    // Storage: #dbff16
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#dbff16', radius: rads, stroke: '#dbff16'});
                    break;
                case 6:
                    // Link: #deff5b
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#deff5b', radius: rads, stroke: '#deff5b'});
                    break;
                case 7:
                    // Lab: #7c39ff
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#7c39ff', radius: rads, stroke: '#7c39ff'});
                    break;
                case 8:
                    // Terminal: #55ff91
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#55ff91', radius: rads, stroke: '#55ff91'});
                    break;
                case 9:
                    // Observer: #5bff86
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#5bff86', radius: rads, stroke: '#5bff86'});
                    break;
                case 10:
                    // Extractor: #a0a0a0
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#a0a0a0', radius: rads, stroke: '#a0a0a0'});
                    break;
                case 11:
                    // Container: #ffe847
                    new RoomVisual(curRoomName).circle(x, y, {fill: '#ffe847', radius: rads, stroke: '#ffe847'});
                    break;
                default:
                    break;
            }
        }
        
        // Function to work through the structures that may be destroyed
        if (!(Game.time % 5)) {
            if (curRoom.memory.structuresAtRisk.length) {
                for (var a in curRoom.memory.structuresAtRisk) {
                    var curTile = curRoom.lookAt(curRoom.memory.structuresAtRisk[a].x, curRoom.memory.structuresAtRisk[a].y);
                    var isDestroyed = true;
                    tileChecker:
                    for (var b in curTile) {
                        if (curTile[b].type === 'structure' && curTile[b].structureType === curRoom.memory.structuresAtRisk[a].t) {
                            if ((curTile[b].hits / curTile[b].hitsMax) >= 0.25) {
                                curRoom.memory.structuresAtRisk.splice(a, 1);
                                isDestroyed = false;
                                break tileChecker;
                            }
                        }
                        else if (curTile[b].type === 'constructionSite' && curTile[b].structureType === curRoom.memory.structuresAtRisk[a].t) {
                            isDestroyed = false;
                        }
                    }
                    if (isDestroyed) {
                        queueBuild(curRoom.memory.structuresAtRisk[a].x, curRoom.memory.structuresAtRisk[a].y, curRoom.memory.structuresAtRisk[a].t);
                    }
                }
            }
        }
        
        // This will visualize the blueprint of the nexus 
        if (!(Game.time % 100)) {
            new RoomVisual(curRoom.name).clear();
            if (curRoom.memory.plan.planQueue.length) {
                for (var a in curRoom.memory.plan.planQueue) {
                    visualizeBlueprint(curRoom.name, curRoom.memory.plan.planQueue[a].structureType, curRoom.memory.plan.planQueue[a].x, curRoom.memory.plan.planQueue[a].y);
                }
            }
        }
        
        // Road: 0          | Extension: 1  | Tower: 2      | Spawn: 3
        // Power Spawn: 4   | Storage: 5    | Link: 6       | Lab: 7
        // Terminal: 8      | Observer: 9   | Extractor: 10 | Container: 11
        
        // Function to test if we are below the limit of a given structure
        function checkLimit(structType) {
            var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == structType).length;
            var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == structType).length;
            var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == structType).length;
            var curLimit = CONTROLLER_STRUCTURES[structType][curRoom.controller.level];
            return (trial + trial2 + trial3 < curLimit);
        }
        
        // Function to queue the first structure of the given type
        function queueFirst(structType, structMarker) {
            for (var i in curRoom.memory.plan.planQueue) {
                if (curRoom.memory.plan.planQueue[i].structureType == structMarker) {
                    queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, structType);
                    curRoom.memory.plan.planQueue.splice(i, 1);
                    return true;
                }
            }
        }
        
        // This iterates through the planQueue to move stuff into the build queue
        if (curRoom.memory.plan.planQueue.length) {
            if (checkLimit(STRUCTURE_EXTENSION)) {
                queueFirst(STRUCTURE_EXTENSION, 1);
            }
            else {
                if (checkLimit(STRUCTURE_TOWER)) {
                    queueFirst(STRUCTURE_TOWER, 2);
                }
                else {
                    if (checkLimit(STRUCTURE_SPAWN)) {
                        queueFirst(STRUCTURE_SPAWN, 3);
                    }
                    else {
                        if (checkLimit(STRUCTURE_POWER_SPAWN)) {
                            queueFirst(STRUCTURE_POWER_SPAWN, 4);
                        }
                        else {
                            if (checkLimit(STRUCTURE_STORAGE)) {
                                queueFirst(STRUCTURE_STORAGE, 5);
                            }
                            else {
                                if (checkLimit(STRUCTURE_LINK)) {
                                    queueFirst(STRUCTURE_LINK, 6);
                                }
                                else {
                                    if (checkLimit(STRUCTURE_LAB)) {
                                        queueFirst(STRUCTURE_LAB, 7);
                                    }
                                    else {
                                        if (checkLimit(STRUCTURE_TERMINAL)) {
                                            queueFirst(STRUCTURE_TERMINAL, 8);
                                        }
                                        else {
                                            if (checkLimit(STRUCTURE_OBSERVER)) {
                                                queueFirst(STRUCTURE_OBSERVER, 9);
                                            }
                                            else {
                                                if (checkLimit(STRUCTURE_EXTRACTOR)) {
                                                    queueFirst(STRUCTURE_EXTRACTOR, 10);
                                                }
                                                else {
                                                    if (checkLimit(STRUCTURE_CONTAINER)) {
                                                        queueFirst(STRUCTURE_CONTAINER, 11);
                                                    }
                                                    else if (curRoom.memory.buildQueue.length < 5) {
                                                        if (checkLimit(STRUCTURE_ROAD)) {
                                                            queueFirst(STRUCTURE_ROAD, 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        /*
        if (curRoom.memory.plan.planQueue.length) {
            var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION).length;
            var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION).length;
            var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION).length;
            var curLimit = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][curRoom.controller.level];
            if (trial + trial2 + trial3 < curLimit) {
                findFirst:
                for (var i in curRoom.memory.plan.planQueue) {
                    if (curRoom.memory.plan.planQueue[i].structureType == 1) {
                        queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_EXTENSION);
                        curRoom.memory.plan.planQueue.splice(i, 1);
                        break findFirst;
                    }
                }
            }
            else {
                trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_TOWER).length;
                trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_TOWER).length;
                trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_TOWER).length;
                curLimit = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][curRoom.controller.level];
                if (trial + trial2 + trial3 < curLimit) {
                    findFirst:
                    for (var i in curRoom.memory.plan.planQueue) {
                        if (curRoom.memory.plan.planQueue[i].structureType == 2) {
                            queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_TOWER);
                            curRoom.memory.plan.planQueue.splice(i, 1);
                            break findFirst;
                        }
                    }
                }
                else {
                    trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_SPAWN).length;
                    trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_SPAWN).length;
                    trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_SPAWN).length;
                    curLimit = CONTROLLER_STRUCTURES[STRUCTURE_SPAWN][curRoom.controller.level];
                    if (trial + trial2 + trial3 < curLimit) {
                        findFirst:
                        for (var i in curRoom.memory.plan.planQueue) {
                            if (curRoom.memory.plan.planQueue[i].structureType == 3) {
                                queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_SPAWN);
                                curRoom.memory.plan.planQueue.splice(i, 1);
                                break findFirst;
                            }
                        }
                    }
                    else {
                        trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_POWER_SPAWN).length;
                        trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_POWER_SPAWN).length;
                        trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_POWER_SPAWN).length;
                        curLimit = CONTROLLER_STRUCTURES[STRUCTURE_POWER_SPAWN][curRoom.controller.level];
                        if (trial + trial2 + trial3 < curLimit) {
                            findFirst:
                            for (var i in curRoom.memory.plan.planQueue) {
                                if (curRoom.memory.plan.planQueue[i].structureType == 4) {
                                    queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_POWER_SPAWN);
                                    curRoom.memory.plan.planQueue.splice(i, 1);
                                    break findFirst;
                                }
                            }
                        }
                        else {
                            trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_STORAGE).length;
                            trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_STORAGE).length;
                            trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_STORAGE).length;
                            curLimit = CONTROLLER_STRUCTURES[STRUCTURE_STORAGE][curRoom.controller.level];
                            if (trial + trial2 + trial3 < curLimit) {
                                findFirst:
                                for (var i in curRoom.memory.plan.planQueue) {
                                    if (curRoom.memory.plan.planQueue[i].structureType == 5) {
                                        queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_STORAGE);
                                        curRoom.memory.plan.planQueue.splice(i, 1);
                                        break findFirst;
                                    }
                                }
                            }
                            else {
                                trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_LINK).length;
                                trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_LINK).length;
                                trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_LINK).length;
                                curLimit = CONTROLLER_STRUCTURES[STRUCTURE_LINK][curRoom.controller.level];
                                if (trial + trial2 + trial3 < curLimit) {
                                    findFirst:
                                    for (var i in curRoom.memory.plan.planQueue) {
                                        if (curRoom.memory.plan.planQueue[i].structureType == 6) {
                                            queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_LINK);
                                            curRoom.memory.plan.planQueue.splice(i, 1);
                                            break findFirst;
                                        }
                                    }
                                }
                                else {
                                    trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_LAB).length;
                                    trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_LAB).length;
                                    trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_LAB).length;
                                    curLimit = CONTROLLER_STRUCTURES[STRUCTURE_LAB][curRoom.controller.level];
                                    if (trial + trial2 + trial3 < curLimit) {
                                        findFirst:
                                        for (var i in curRoom.memory.plan.planQueue) {
                                            if (curRoom.memory.plan.planQueue[i].structureType == 7) {
                                                queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_LAB);
                                                curRoom.memory.plan.planQueue.splice(i, 1);
                                                break findFirst;
                                            }
                                        }
                                    }
                                    else {
                                        trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_TERMINAL).length;
                                        trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_TERMINAL).length;
                                        trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_TERMINAL).length;
                                        curLimit = CONTROLLER_STRUCTURES[STRUCTURE_TERMINAL][curRoom.controller.level];
                                        if (trial + trial2 + trial3 < curLimit) {
                                            findFirst:
                                            for (var i in curRoom.memory.plan.planQueue) {
                                                if (curRoom.memory.plan.planQueue[i].structureType == 8) {
                                                    queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_TERMINAL);
                                                    curRoom.memory.plan.planQueue.splice(i, 1);
                                                    break findFirst;
                                                }
                                            }
                                        }
                                        else {
                                            trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_OBSERVER).length;
                                            trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_OBSERVER).length;
                                            trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_OBSERVER).length;
                                            curLimit = CONTROLLER_STRUCTURES[STRUCTURE_OBSERVER][curRoom.controller.level];
                                            if (trial + trial2 + trial3 < curLimit && false) {
                                                findFirst:
                                                for (var i in curRoom.memory.plan.planQueue) {
                                                    if (curRoom.memory.plan.planQueue[i].structureType == 9) {
                                                        queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_OBSERVER);
                                                        curRoom.memory.plan.planQueue.splice(i, 1);
                                                        break findFirst;
                                                    }
                                                }
                                            }
                                            else {
                                                trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTRACTOR).length;
                                                trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTRACTOR).length;
                                                trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTRACTOR).length;
                                                curLimit = CONTROLLER_STRUCTURES[STRUCTURE_EXTRACTOR][curRoom.controller.level];
                                                if (trial + trial2 + trial3 < curLimit && false) {
                                                    findFirst:
                                                    for (var i in curRoom.memory.plan.planQueue) {
                                                        if (curRoom.memory.plan.planQueue[i].structureType == 10) {
                                                            queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_EXTRACTOR);
                                                            curRoom.memory.plan.planQueue.splice(i, 1);
                                                            break findFirst;
                                                        }
                                                    }
                                                }
                                                else {
                                                    trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_CONTAINER).length;
                                                    trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_CONTAINER).length;
                                                    trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_CONTAINER).length;
                                                    curLimit = CONTROLLER_STRUCTURES[STRUCTURE_CONTAINER][curRoom.controller.level];
                                                    if (trial + trial2 + trial3 < curLimit && false) {
                                                        findFirst:
                                                        for (var i in curRoom.memory.plan.planQueue) {
                                                            if (curRoom.memory.plan.planQueue[i].structureType == 11) {
                                                                queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_CONTAINER);
                                                                curRoom.memory.plan.planQueue.splice(i, 1);
                                                                break findFirst;
                                                            }
                                                        }
                                                    }
                                                    else if (curRoom.memory.buildQueue.length < 5) {
                                                        trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_ROAD).length;
                                                        trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_ROAD).length;
                                                        trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_ROAD).length;
                                                        curLimit = CONTROLLER_STRUCTURES[STRUCTURE_ROAD][curRoom.controller.level];
                                                        if (trial + trial2 + trial3 < curLimit) {
                                                            findFirst:
                                                            for (var i in curRoom.memory.plan.planQueue) {
                                                                if (curRoom.memory.plan.planQueue[i].structureType == 0) {
                                                                    queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_ROAD);
                                                                    curRoom.memory.plan.planQueue.splice(i, 1);
                                                                    break findFirst;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        */
        if (extensions.length >= 5 && !curRoom.memory.sourceRoad[0]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[0].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => (schematic.type == STRUCTURE_SPAWN || schematic.type == STRUCTURE_WALL || schematic.type == STRUCTURE_EXTENSION || schematic.type == STRUCTURE_LINK || schematic.type == STRUCTURE_STORAGE || schematic.type == STRUCTURE_TOWER || schematic.type == STRUCTURE_OBSERVER || schematic.type == STRUCTURE_POWER_SPAWN || schematic.type == STRUCTURE_LAB || schematic.type == STRUCTURE_TERMINAL || schematic.type == STRUCTURE_NUKER));
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[0] = true;
        }
        
        if (containers.length == 1 && !curRoom.memory.sourceRoad[1]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[1].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => (schematic.type == STRUCTURE_SPAWN || schematic.type == STRUCTURE_WALL || schematic.type == STRUCTURE_EXTENSION || schematic.type == STRUCTURE_LINK || schematic.type == STRUCTURE_STORAGE || schematic.type == STRUCTURE_TOWER || schematic.type == STRUCTURE_OBSERVER || schematic.type == STRUCTURE_POWER_SPAWN || schematic.type == STRUCTURE_LAB || schematic.type == STRUCTURE_TERMINAL || schematic.type == STRUCTURE_NUKER));
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[1] = true;
        }
        
        if (containers.length == 2 && !curRoom.memory.sourceRoad[2]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[3].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => (schematic.type == STRUCTURE_SPAWN || schematic.type == STRUCTURE_WALL || schematic.type == STRUCTURE_EXTENSION || schematic.type == STRUCTURE_LINK || schematic.type == STRUCTURE_STORAGE || schematic.type == STRUCTURE_TOWER || schematic.type == STRUCTURE_OBSERVER || schematic.type == STRUCTURE_POWER_SPAWN || schematic.type == STRUCTURE_LAB || schematic.type == STRUCTURE_TERMINAL || schematic.type == STRUCTURE_NUKER));
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            buildControllerRoad();
            curRoom.memory.sourceRoad[2] = true;
        }
        
        var curSpawn = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_SPAWN)[0];
        var towerCap = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][curRoom.controller.level];
        var spawnPos = curSpawn.pos;
        var storageLoc = {x: (spawnPos.x - 1), y: spawnPos.y};
        
        var numTowersQueued = 0;
        for (var i in curRoom.memory.buildQueue) {
            if (curRoom.memory.buildQueue[i].type == STRUCTURE_TOWER) {
                numTowersQueued++;
            }
        }
        
        var towerCoords = [{x: storageLoc.x - 5, y: storageLoc.y - 1},{x: storageLoc.x - 5, y: storageLoc.y + 1},{x: storageLoc.x + 5, y: storageLoc.y - 1},{x: storageLoc.x + 5, y: storageLoc.y + 1},{x: storageLoc.x - 1, y: storageLoc.y - 5},{x: storageLoc.x - 1, y: storageLoc.y + 5},{x: storageLoc.x + 1, y: storageLoc.y - 5},{x: storageLoc.x + 1, y: storageLoc.y + 5}];
        
        if (numTowers + numTowersQueued < towerCap && extensions.length == CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][curRoom.controller.level]) {
            doCoords:
            for (var i in towerCoords) {
                // Check tile
                var isBadLoc = false;
                // Check if tile is a wall
                if (Game.map.getTerrainAt(towerCoords[i].x, towerCoords[i].y, curRoom.name) == 'wall') {
                    isBadLoc = true;
                }
                else {
                    // Check if there are errors looking at the tile
                    if (curRoom.lookAt(towerCoords[i].x, towerCoords[i].y) < 0) {
                        isBadLoc = true;
                    }
                    else {
                        var tile = curRoom.lookAt(towerCoords[i].x, towerCoords[i].y);
                        tileCheck:
                        for (var i in tile) {
                            // Check if tile has a structure
                            if (tile[i].type == LOOK_STRUCTURES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                            // Check if tile has a construction site
                            if (tile[i].type == LOOK_CONSTRUCTION_SITES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                        }
                    }
                }
                if (!isBadLoc) {
                    // Queue construction of tower
                    queueBuild(towerCoords[i].x, towerCoords[i].y, STRUCTURE_TOWER);
                    numTowersQueued++;
                    // Break loop on size cap
                    if (numTowers + numTowersQueued >= towerCap) {
                        break doCoords;
                    }
                }
            }
        }
        
        if (numTowers && !curRoom.memory.sourceRoad[3]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[2].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => (schematic.type == STRUCTURE_SPAWN || schematic.type == STRUCTURE_WALL || schematic.type == STRUCTURE_EXTENSION || schematic.type == STRUCTURE_LINK || schematic.type == STRUCTURE_STORAGE || schematic.type == STRUCTURE_TOWER || schematic.type == STRUCTURE_OBSERVER || schematic.type == STRUCTURE_POWER_SPAWN || schematic.type == STRUCTURE_LAB || schematic.type == STRUCTURE_TERMINAL || schematic.type == STRUCTURE_NUKER));
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => (schematic.structureType == STRUCTURE_SPAWN || schematic.structureType == STRUCTURE_WALL || schematic.structureType == STRUCTURE_EXTENSION || schematic.structureType == STRUCTURE_LINK || schematic.structureType == STRUCTURE_STORAGE || schematic.structureType == STRUCTURE_TOWER || schematic.structureType == STRUCTURE_OBSERVER || schematic.structureType == STRUCTURE_POWER_SPAWN || schematic.structureType == STRUCTURE_LAB || schematic.structureType == STRUCTURE_TERMINAL || schematic.structureType == STRUCTURE_NUKER));
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[3] = true;
        }
        
        if (containers.length == 4) {
            queueBuild(containers[3].pos.x, containers[3].pos.y, STRUCTURE_RAMPART);
        }
        
        // Destroy roads under extensions to conserve resources
        if (!(Game.time % 1000)) {
            for (let i in extensions) {
                var extTile = curRoom.lookAt(extensions[i].pos);
                for (let j in extTile) {
                    if (extTile[j].type == "structure") {
                        if (extTile[j].structure.structureType == STRUCTURE_ROAD) {
                            Game.getObjectById(extTile[j].structure.id).destroy();
                        }
                    }
                }
            }
        }
        
        if (sites < MAXSITES && curRoom.memory.buildQueue[0]) {
            let site = curRoom.memory.buildQueue[0];
            curRoom.createConstructionSite(site.x, site.y, site.type)
            curRoom.memory.buildQueue.shift();
        }
    }
}

module.exports = maintainStructures;
