var maintainStructures = {
    
    run: function() {
        if (!Memory.repairSites) Memory.repairSites = [];
        if (!Memory.sourceRoad) Memory.sourceRoad = [];
        if (!Memory.buildQueue) Memory.buildQueue = [];
        
        const MAXSITES = 3;
        
        var spawns = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_SPAWN);
        var extensions = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_EXTENSION);
        var containers = Game.rooms['sim'].find(FIND_STRUCTURES, {
            filter: (structure) => {
                return structure.structureType == STRUCTURE_CONTAINER;
            }
        });
        var sources = Game.rooms['sim'].find(FIND_SOURCES);
        
        var constructionSites = Game.rooms['sim'].find(FIND_CONSTRUCTION_SITES);
        var sites = constructionSites.length;
        
        var numFighters = _.filter(Game.creeps, (creep) => creep.memory.role == 'fighter').length;
        var numHealers = _.filter(Game.creeps, (creep) => creep.memory.role == 'healer').length;
        var numTowers = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_TOWER).length;
        
        if (!(Game.time % 100) && !sites) {
             var repairSites = Game.rooms['sim'].find(FIND_STRUCTURES, {
                filter: (structure) => {
                    if (Game.rooms['sim'].find(FIND_HOSTILE_CREEPS).length) {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART);
                    } else {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART); //  Fix anything below %
                    }
                }
            });
            Memory.repairSites = [];
            for (let i in repairSites) {
                Memory.repairSites[i] = repairSites[i].id;
            }
        }
        
        // Function to add new construction sites to a list for building
        function queueBuild(x, y, type) {
            if (!Memory.buildQueue) Memory.buildQueue = [];
            for (let i in Memory.buildQueue) {
                if (x == Memory.buildQueue[i].x && y == Memory.buildQueue[i].y) {
                    return -1;
                }
            }
            if ((!Game.rooms['sim'].lookForAt(LOOK_STRUCTURES,x,y)[0]) || type == STRUCTURE_RAMPART) {
                Memory.buildQueue.push({x:x,y:y,type:type});
            }
        }
        
        // Queues up construction for a path
        function buildRoad(path, end) {
            for (let i in path) {
                if (i < (path.length - 2)) {
                    queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
                } else {
                    queueBuild(path[i].x,path[i].y, end);
                }
            }
        }
        
        // Build road around controller
        function buildControllerRoad() {
            var path = Game.rooms['sim'].findPath(spawns[0].pos,Game.rooms['sim'].controller.pos, {ignoreCreeps: true});
            for (let i = 0; i < (path.length - 5); i++) {
                queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(Game.rooms['sim'].controller.pos.x + i, Game.rooms['sim'].controller.pos.y + 4, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(Game.rooms['sim'].controller.pos.x - 4, Game.rooms['sim'].controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(Game.rooms['sim'].controller.pos.x + 4, Game.rooms['sim'].controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(Game.rooms['sim'].controller.pos.x + i, Game.rooms['sim'].controller.pos.y - 4, STRUCTURE_ROAD);
            }
        }
        
        // Extension queue start
        if (Game.spawns['Spawn1'].memory.nexus.length) {
            if (extensions.length < Game.spawns['Spawn1'].memory.nexus.length) {
                for (var i in Game.spawns['Spawn1'].memory.nexus) {
                    var isBuilt = false;
                    builtCheck:
                    for (var j in extensions) {
                        if (Game.spawns['Spawn1'].memory.nexus[i].x == extensions[j].x && Game.spawns['Spawn1'].memory.nexus[i].y == extensions[j].y) {
                            isBuilt = true;
                            break builtCheck;
                        }
                    }
                    if (!isBuilt) {
                        queueBuild(Game.spawns['Spawn1'].memory.nexus[i].x, Game.spawns['Spawn1'].memory.nexus[i].y, STRUCTURE_EXTENSION);
                    }
                }
            }
        }
        // Extension queue end
        
        if (extensions.length == 5 && !Memory.sourceRoad[0]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[0].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            queueBuild(spawns[0].pos.x + 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x - 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y + 1, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y - 1, STRUCTURE_ROAD);
            Memory.sourceRoad[0] = true;
        }
        
        if (containers.length == 1 && !Memory.sourceRoad[1]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[1].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            Memory.sourceRoad[1] = true;
        }
        
        if (containers.length == 2 && !Memory.sourceRoad[2]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[3].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            buildControllerRoad();
            Memory.sourceRoad[2] = true;
        }
        
        if (Game.rooms['sim'].controller.level >= 3 && extensions.length == 5) {
            queueBuild(Game.spawns['Spawn1'].pos.x + 2,Game.spawns['Spawn1'].pos.y, STRUCTURE_TOWER);
        }
        
        if (Game.rooms['sim'].controller.level >= 5 && extensions.length == 20) {
            queueBuild(Game.spawns['Spawn1'].pos.x,Game.spawns['Spawn1'].pos.y + 2, STRUCTURE_TOWER);
        }
        
        if (numTowers && !Memory.sourceRoad[3]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[2].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            Memory.sourceRoad[3] = true;
        }
        
        if (containers.length == 4) {
            queueBuild(containers[3].pos.x, containers[3].pos.y, STRUCTURE_RAMPART);
        }
        
        // queue building of roads around extensions **IMPROVE THIS
        if (!(Game.time % 1000)) {
            for (let i in extensions) {
                queueBuild(extensions[i].pos.x + 1, extensions[i].pos.y, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x - 1, extensions[i].pos.y, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x, extensions[i].pos.y + 1, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x, extensions[i].pos.y - 1, STRUCTURE_ROAD);
            }
        }
        
        if (sites < MAXSITES && Memory.buildQueue[0]) {
            let site = Memory.buildQueue[0];
            Game.rooms['sim'].createConstructionSite(site.x, site.y, site.type)
            Memory.buildQueue.shift();
        }
    }
}

module.exports = maintainStructures;
