var maintainStructures = {
    
    run: function(curRoom) {
        if (!curRoom.memory.repairSites) curRoom.memory.repairSites = [];
        if (!curRoom.memory.sourceRoad) curRoom.memory.sourceRoad = [];
        if (!curRoom.memory.buildQueue) curRoom.memory.buildQueue = [];
        
        const MAXSITES = 3;
        
        var allStructuresInRoom = curRoom.find(FIND_STRUCTURES);
        
        var spawns = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_SPAWN);
        var extensions = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_EXTENSION);
        var containers = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_CONTAINER);
        
        var sources = curRoom.find(FIND_SOURCES);
        
        var constructionSites = curRoom.find(FIND_CONSTRUCTION_SITES);
        var sites = constructionSites.length;
        
        var allCreepsInRoom = curRoom.find(FIND_MY_CREEPS);
        
        var numFighters = _.filter(allCreepsInRoom, (creep) => creep.memory.role == 'fighter').length;
        var numHealers = _.filter(allCreepsInRoom, (creep) => creep.memory.role == 'healer').length;
        var numTowers = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_TOWER).length;
        
        if (!(Game.time % 100) && !sites) {
             var repairSites = _.filter(allStructuresInRoom, (structure) => {
                    if (curRoom.find(FIND_HOSTILE_CREEPS).length) {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART);
                    } else {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART); //  Fix anything below %
                    }
                });
            curRoom.memory.repairSites = [];
            for (let i in repairSites) {
                curRoom.memory.repairSites[i] = repairSites[i].id;
            }
        }
        
        // Function to add new construction sites to a list for building
        function queueBuild(x, y, type) {
            if (!curRoom.memory.buildQueue) curRoom.memory.buildQueue = [];
            for (let i in curRoom.memory.buildQueue) {
                if (x == curRoom.memory.buildQueue[i].x && y == curRoom.memory.buildQueue[i].y) {
                    return -1;
                }
            }
            if ((!curRoom.lookForAt(LOOK_STRUCTURES,x,y)[0]) || type == STRUCTURE_RAMPART) {
                curRoom.memory.buildQueue.push({x:x,y:y,type:type});
            }
        }
        
        // Queues up construction for a path
        function buildRoad(path, end) {
            for (let i in path) {
                if (i < (path.length - 2)) {
                    queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
                } else {
                    queueBuild(path[i].x,path[i].y, end);
                }
            }
        }
        
        // Build road around controller
        function buildControllerRoad() {
            var path = curRoom.findPath(spawns[0].pos,curRoom.controller.pos, {ignoreCreeps: true});
            for (let i = 0; i < (path.length - 5); i++) {
                queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(curRoom.controller.pos.x + i, curRoom.controller.pos.y + 4, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(curRoom.controller.pos.x - 4, curRoom.controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(curRoom.controller.pos.x + 4, curRoom.controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(curRoom.controller.pos.x + i, curRoom.controller.pos.y - 4, STRUCTURE_ROAD);
            }
        }
        
        // Rework this to shift the planQueue with every iteration, checking if the returned item can be built, and appending it back to the end of the planQueue if it can't
        /*
        if (curRoom.memory.plan.planQueue.length) {
            var firstItem = curRoom.memory.plan.planQueue.shift();
            switch (firstItem.structureType) {
                case 0:
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_ROAD).length;
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_ROAD).length;
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_ROAD).length;
                    var limit = CONTROLLER_STRUCTURES[STRUCTURE_ROAD][curRoom.controller.level];
                    
                    if (trial + trial2 + trial3 < limit) {
                        queueBuild(firstItem.x, firstItem.y, STRUCTURE_ROAD);
                    }
                    else {
                        curRoom.memory.plan.planQueue.push(firstItem);
                    }
                    break;
                case 1:
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION).length;
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION).length;
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION).length;
                    var limit = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][curRoom.controller.level];
                    
                    if (trial + trial2 + trial3 < limit) {
                        queueBuild(firstItem.x, firstItem.y, STRUCTURE_EXTENSION);
                    }
                    else {
                        curRoom.memory.plan.planQueue.push(firstItem);
                    }
                    break;
                case 2:
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_SPAWN).length;
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_SPAWN).length;
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_SPAWN).length;
                    var limit = CONTROLLER_STRUCTURES[STRUCTURE_SPAWN][curRoom.controller.level];
                    
                    if (trial + trial2 + trial3 < limit) {
                        queueBuild(firstItem.x, firstItem.y, STRUCTURE_SPAWN);
                    }
                    else {
                        curRoom.memory.plan.planQueue.push(firstItem);
                    }
                    break;
                case 3:
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_STORAGE).length;
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_STORAGE).length;
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_STORAGE).length;
                    var limit = CONTROLLER_STRUCTURES[STRUCTURE_STORAGE][curRoom.controller.level];
                    
                    if (trial + trial2 + trial3 < limit) {
                        queueBuild(firstItem.x, firstItem.y, STRUCTURE_STORAGE);
                    }
                    else {
                        curRoom.memory.plan.planQueue.push(firstItem);
                    }
                    break;
                case 4:
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_LINK).length;
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_LINK).length;
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_LINK).length;
                    var limit = CONTROLLER_STRUCTURES[STRUCTURE_LINK][curRoom.controller.level];
                    
                    if (trial + trial2 + trial3 < limit) {
                        queueBuild(firstItem.x, firstItem.y, STRUCTURE_LINK);
                    }
                    else {
                        curRoom.memory.plan.planQueue.push(firstItem);
                    }
                    break;
                default:
                    curRoom.memory.plan.planQueue.push(firstItem);
                    break;
            }
        }
        */
        if (curRoom.controller.level >= 2) {
            var numPlannedRoads = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType == 0).length;
            if (numPlannedRoads) {
                planIteration:
                for (var i in curRoom.memory.plan.planQueue) {
                    if (numPlannedRoads) {
                        if (curRoom.memory.plan.planQueue[i].structureType == 0) {
                            queueBuild(curRoom.memory.plan.planQueue[i].x, curRoom.memory.plan.planQueue[i].y, STRUCTURE_ROAD);
                            curRoom.memory.plan.planQueue.splice(i, 1);
                            numPlannedRoads = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType == 0).length;
                        }
                    }
                    else {
                        break planIteration;
                    }
                }
            }
        }
        
        if (curRoom.memory.plan.planQueue.length) {
            if (curRoom.controller.level >= 2) {
                if (curRoom.memory.plan.planQueue[0].structureType == 0) {
                    queueBuild(curRoom.memory.plan.planQueue[0].x, curRoom.memory.plan.planQueue[0].y, STRUCTURE_ROAD);
                    curRoom.memory.plan.planQueue.shift();
                }
                else if (curRoom.memory.plan.planQueue[0].structureType == 1) {
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION);
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                    var curMaxExtensions = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][curRoom.controller.level];
                    
                    if (trial.length + trial2.length + trial3.length < curMaxExtensions) {
                        queueBuild(curRoom.memory.plan.planQueue[0].x, curRoom.memory.plan.planQueue[0].y, STRUCTURE_EXTENSION);
                        curRoom.memory.plan.planQueue.shift();
                    }
                }
                else if (curRoom.memory.plan.planQueue[0].structureType == 2) {
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_SPAWN);
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_SPAWN);
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_SPAWN);
                    var curMaxSpawns = CONTROLLER_STRUCTURES[STRUCTURE_SPAWN][curRoom.controller.level];
                    
                    if (trial.length + trial2.length + trial3.length < curMaxSpawns) {
                        queueBuild(curRoom.memory.plan.planQueue[0].x, curRoom.memory.plan.planQueue[0].y, STRUCTURE_SPAWN);
                        curRoom.memory.plan.planQueue.shift();
                    }
                }
                else if (curRoom.memory.plan.planQueue[0].structureType == 3) {
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_STORAGE);
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_STORAGE);
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_STORAGE);
                    var curMaxStorages = CONTROLLER_STRUCTURES[STRUCTURE_STORAGE][curRoom.controller.level];
                    
                    if (trial.length + trial2.length + trial3.length < curMaxStorages) {
                        queueBuild(curRoom.memory.plan.planQueue[0].x, curRoom.memory.plan.planQueue[0].y, STRUCTURE_STORAGE);
                        curRoom.memory.plan.planQueue.shift();
                    }
                }
                else if (curRoom.memory.plan.planQueue[0].structureType == 4) {
                    var trial = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_LINK);
                    var trial2 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_LINK);
                    var trial3 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_LINK);
                    var curMaxLinks = CONTROLLER_STRUCTURES[STRUCTURE_LINK][curRoom.controller.level];
                    
                    if (trial.length + trial2.length + trial3.length < curMaxLinks) {
                        queueBuild(curRoom.memory.plan.planQueue[0].x, curRoom.memory.plan.planQueue[0].y, STRUCTURE_LINK);
                        curRoom.memory.plan.planQueue.shift();
                    }
                }
            }
        }
        
        if (extensions.length >= 5 && !curRoom.memory.sourceRoad[0]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[0].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION);
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            /*
            queueBuild(spawns[0].pos.x + 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x - 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y + 1, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y - 1, STRUCTURE_ROAD);
            */
            curRoom.memory.sourceRoad[0] = true;
        }
        
        if (containers.length == 1 && !curRoom.memory.sourceRoad[1]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[1].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION);
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[1] = true;
        }
        
        if (containers.length == 2 && !curRoom.memory.sourceRoad[2]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[3].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION);
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            buildControllerRoad();
            curRoom.memory.sourceRoad[2] = true;
        }
        
        var curSpawn = _.filter(allStructuresInRoom, (structure) => structure.structureType == STRUCTURE_SPAWN)[0];
        var towerCap = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][curRoom.controller.level];
        var spawnPos = curSpawn.pos;
        
        var numTowersQueued = 0;
        for (var i in curRoom.memory.buildQueue) {
            if (curRoom.memory.buildQueue[i].type == STRUCTURE_TOWER) {
                numTowersQueued++;
            }
        }
        
        var towerCoords = [{x: spawnPos.x - 5, y: spawnPos.y - 1},{x: spawnPos.x - 5, y: spawnPos.y + 1},{x: spawnPos.x + 5, y: spawnPos.y - 1},{x: spawnPos.x + 5, y: spawnPos.y + 1},{x: spawnPos.x - 1, y: spawnPos.y - 5},{x: spawnPos.x - 1, y: spawnPos.y + 5},{x: spawnPos.x + 1, y: spawnPos.y - 5},{x: spawnPos.x + 1, y: spawnPos.y + 5}];
        
        if (numTowers + numTowersQueued < towerCap && extensions.length == CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][curRoom.controller.level]) {
            doCoords:
            for (var i in towerCoords) {
                // Check tile
                var isBadLoc = false;
                // Check if tile is a wall
                if (Game.map.getTerrainAt(towerCoords[i].x, towerCoords[i].y, curRoom.name) == 'wall') {
                    isBadLoc = true;
                }
                else {
                    // Check if there are errors looking at the tile
                    if (curRoom.lookAt(towerCoords[i].x, towerCoords[i].y) < 0) {
                        isBadLoc = true;
                    }
                    else {
                        var tile = curRoom.lookAt(towerCoords[i].x, towerCoords[i].y);
                        tileCheck:
                        for (var i in tile) {
                            // Check if tile has a structure
                            if (tile[i].type == LOOK_STRUCTURES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                            // Check if tile has a construction site
                            if (tile[i].type == LOOK_CONSTRUCTION_SITES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                        }
                    }
                }
                if (!isBadLoc) {
                    // Queue construction of tower
                    queueBuild(towerCoords[i].x, towerCoords[i].y, STRUCTURE_TOWER);
                    numTowersQueued++;
                    // Break loop on size cap
                    if (numTowers + numTowersQueued >= towerCap) {
                        break doCoords;
                    }
                }
            }
        }
        
        if (numTowers && !curRoom.memory.sourceRoad[3]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[2].pos, {ignoreCreeps: true, costCallback: function(roomName, costMatrix) {
                var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType >= 1);
                var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.type == STRUCTURE_EXTENSION);
                var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
                
                for (var a in trial) {
                    costMatrix.set(trial[a].x, trial[a].y, 255);
                }
                for (var a in trial2) {
                    costMatrix.set(trial2[a].x, trial2[a].y, 255);
                }
                for (var a in trial3) {
                    costMatrix.set(trial3[a].pos.x, trial3[a].pos.y, 255);
                }
                for (var a in trial4) {
                    costMatrix.set(trial4[a].pos.x, trial4[a].pos.y, 255);
                }
            }}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[3] = true;
        }
        
        if (containers.length == 4) {
            queueBuild(containers[3].pos.x, containers[3].pos.y, STRUCTURE_RAMPART);
        }
        
        // Queue building of roads around extensions **IMPROVE THIS
        if (!(Game.time % 1000)) {
            for (let i in extensions) {
                //queueBuild(extensions[i].pos.x + 1, extensions[i].pos.y, STRUCTURE_ROAD);
                //queueBuild(extensions[i].pos.x - 1, extensions[i].pos.y, STRUCTURE_ROAD);
                //queueBuild(extensions[i].pos.x, extensions[i].pos.y + 1, STRUCTURE_ROAD);
                //queueBuild(extensions[i].pos.x, extensions[i].pos.y - 1, STRUCTURE_ROAD);
                var extTile = curRoom.lookAt(extensions[i].pos.x, extensions[i].pos.y);
                for (let j in extTile) {
                    if (extTile[j].structureType == STRUCTURE_ROAD) {
                        extTile[j].destroy();
                    }
                }
            }
        }
        
        if (sites < MAXSITES && curRoom.memory.buildQueue[0]) {
            let site = curRoom.memory.buildQueue[0];
            curRoom.createConstructionSite(site.x, site.y, site.type)
            curRoom.memory.buildQueue.shift();
        }
    }
}

module.exports = maintainStructures;
