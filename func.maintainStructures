var maintainStructures = {
    
    run: function(curRoom) {
        if (!curRoom.memory.repairSites) curRoom.memory.repairSites = [];
        if (!curRoom.memory.sourceRoad) curRoom.memory.sourceRoad = [];
        if (!curRoom.memory.buildQueue) curRoom.memory.buildQueue = [];
        
        const MAXSITES = 3;
        
        var spawns = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_SPAWN);
        var extensions = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_EXTENSION);
        var containers = curRoom.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return structure.structureType == STRUCTURE_CONTAINER;
            }
        });
        var sources = curRoom.find(FIND_SOURCES);
        
        var constructionSites = curRoom.find(FIND_CONSTRUCTION_SITES);
        var sites = constructionSites.length;
        
        var numFighters = _.filter(Game.creeps, (creep) => creep.memory.role == 'fighter').length;
        var numHealers = _.filter(Game.creeps, (creep) => creep.memory.role == 'healer').length;
        var numTowers = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_TOWER).length;
        
        if (!(Game.time % 100) && !sites) {
             var repairSites = curRoom.find(FIND_STRUCTURES, {
                filter: (structure) => {
                    if (curRoom.find(FIND_HOSTILE_CREEPS).length) {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART);
                    } else {
                        return (structure.hits < (structure.hitsMax * .9) && structure.structureType != STRUCTURE_RAMPART); //  Fix anything below %
                    }
                }
            });
            curRoom.memory.repairSites = [];
            for (let i in repairSites) {
                curRoom.memory.repairSites[i] = repairSites[i].id;
            }
        }
        
        // Function to add new construction sites to a list for building
        function queueBuild(x, y, type) {
            if (!curRoom.memory.buildQueue) curRoom.memory.buildQueue = [];
            for (let i in curRoom.memory.buildQueue) {
                if (x == curRoom.memory.buildQueue[i].x && y == curRoom.memory.buildQueue[i].y) {
                    return -1;
                }
            }
            if ((!curRoom.lookForAt(LOOK_STRUCTURES,x,y)[0]) || type == STRUCTURE_RAMPART) {
                curRoom.memory.buildQueue.push({x:x,y:y,type:type});
            }
        }
        
        // Queues up construction for a path
        function buildRoad(path, end) {
            for (let i in path) {
                if (i < (path.length - 2)) {
                    queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
                } else {
                    queueBuild(path[i].x,path[i].y, end);
                }
            }
        }
        
        // Build road around controller
        function buildControllerRoad() {
            var path = curRoom.findPath(spawns[0].pos,curRoom.controller.pos, {ignoreCreeps: true});
            for (let i = 0; i < (path.length - 5); i++) {
                queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(curRoom.controller.pos.x + i, curRoom.controller.pos.y + 4, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(curRoom.controller.pos.x - 4, curRoom.controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = 3; i >= -3; i--) {
                queueBuild(curRoom.controller.pos.x + 4, curRoom.controller.pos.y + i, STRUCTURE_ROAD);
            }
            for (let i = -3; i <= 3; i++) {
                queueBuild(curRoom.controller.pos.x + i, curRoom.controller.pos.y - 4, STRUCTURE_ROAD);
            }
        }
        
        // Extension queue start
        var curSpawn = curRoom.find(FIND_MY_SPAWNS)[0];
        
        if (curSpawn.memory.nexus.length) {
            if (extensions.length < curSpawn.memory.nexus.length) {
                for (var i in curSpawn.memory.nexus) {
                    var isBuilt = false;
                    builtCheck:
                    for (var j in extensions) {
                        if (curSpawn.memory.nexus[i].x == extensions[j].x && curSpawn.memory.nexus[i].y == extensions[j].y) {
                            isBuilt = true;
                            break builtCheck;
                        }
                    }
                    if (!isBuilt) {
                        queueBuild(curSpawn.memory.nexus[i].x, curSpawn.memory.nexus[i].y, STRUCTURE_EXTENSION);
                    }
                }
            }
        }
        // Extension queue end
        
        if (extensions.length >= 5 && !curRoom.memory.sourceRoad[0]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[0].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            queueBuild(spawns[0].pos.x + 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x - 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y + 1, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y - 1, STRUCTURE_ROAD);
            curRoom.memory.sourceRoad[0] = true;
        }
        
        if (containers.length == 1 && !curRoom.memory.sourceRoad[1]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[1].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[1] = true;
        }
        
        if (containers.length == 2 && !curRoom.memory.sourceRoad[2]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[3].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            buildControllerRoad();
            curRoom.memory.sourceRoad[2] = true;
        }
        
        var towerCap = CONTROLLER_STRUCTURES[STRUCTURE_TOWER][curRoom.controller.level];
        var spawnPos = curSpawn.pos;
        
        var numTowersQueued = 0;
        for (var i in curRoom.memory.buildQueue) {
            if (curRoom.memory.buildQueue[i].type == STRUCTURE_TOWER) {
                numTowersQueued++;
            }
        }
        
        towerQueue:
        while (numTowers + numTowersQueued < towerCap) {
            var a = 2;
            while (a >= 0) {
                var b = 2 - a;
                // x + a, y + a
                var curCoord = {x: spawnPos.x + a, y: spawnPos.y + b};
                // Check tile
                var isBadLoc = false;
                // Check if tile is a wall
                if (Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == 'wall' || Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == ERR_NOT_IN_RANGE) {
                    isBadLoc = true;
                }
                else {
                    // Check if there are errors looking at the tile
                    if (curRoom.lookAt(curCoord.x, curCoord.y) < 0) {
                        isBadLoc = true;
                    }
                    else {
                        var tile = curRoom.lookAt(curCoord.x, curCoord.y);
                        tileCheck:
                        for (var i in tile) {
                            // Check if tile has a structure
                            if (tile[i].type == LOOK_STRUCTURES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                            // Check if tile has a construction site
                            if (tile[i].type == LOOK_CONSTRUCTION_SITES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                        }
                    }
                }
                // Check build queue
                if (curRoom.memory.buildQueue) {
                    buildQueueCheck:
                    for (var i in curRoom.memory.buildQueue) {
                        if (curRoom.memory.buildQueue[i].x == curCoord.x && curRoom.memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                }
                if (!isBadLoc) {
                    // Queue construction of tower
                    queueBuild(curCoord.x, curCoord.y, STRUCTURE_TOWER);
                    numTowersQueued++;
                    // Break loop on size cap
                    if (numTowers + numTowersQueued >= towerCap) {
                        break towerQueue;
                    }
                }
                
                // x +  a, y - b
                curCoord = {x: spawnPos.x + a, y: spawnPos.y - b};
                // Check tile
                isBadLoc = false;
                // Check if tile is a wall
                if (Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == 'wall' || Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == ERR_NOT_IN_RANGE) {
                    isBadLoc = true;
                }
                else {
                    // Check if there are errors looking at the tile
                    if (curRoom.lookAt(curCoord.x, curCoord.y) < 0) {
                        isBadLoc = true;
                    }
                    else {
                        var tile = curRoom.lookAt(curCoord.x, curCoord.y);
                        tileCheck:
                        for (var i in tile) {
                            // Check if tile has a structure
                            if (tile[i].type == LOOK_STRUCTURES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                            // Check if tile has a construction site
                            if (tile[i].type == LOOK_CONSTRUCTION_SITES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                        }
                    }
                }
                // Check build queue
                if (curRoom.memory.buildQueue) {
                    buildQueueCheck:
                    for (var i in curRoom.memory.buildQueue) {
                        if (curRoom.memory.buildQueue[i].x == curCoord.x && curRoom.memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                }
                if (!isBadLoc) {
                    // Queue construction of tower
                    queueBuild(curCoord.x, curCoord.y, STRUCTURE_TOWER);
                    numTowersQueued++;
                    // Break loop on size cap
                    if (numTowers + numTowersQueued >= towerCap) {
                        break towerQueue;
                    }
                }
                
                // x - a, y + b
                curCoord = {x: spawnPos.x - a, y: spawnPos.y + b};
                // Check tile
                isBadLoc = false;
                // Check if tile is a wall
                if (Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == 'wall' || Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == ERR_NOT_IN_RANGE) {
                    isBadLoc = true;
                }
                else {
                    // Check if there are errors looking at the tile
                    if (curRoom.lookAt(curCoord.x, curCoord.y) < 0) {
                        isBadLoc = true;
                    }
                    else {
                        var tile = curRoom.lookAt(curCoord.x, curCoord.y);
                        tileCheck:
                        for (var i in tile) {
                            // Check if tile has a structure
                            if (tile[i].type == LOOK_STRUCTURES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                            // Check if tile has a construction site
                            if (tile[i].type == LOOK_CONSTRUCTION_SITES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                        }
                    }
                }
                // Check build queue
                if (curRoom.memory.buildQueue) {
                    buildQueueCheck:
                    for (var i in curRoom.memory.buildQueue) {
                        if (curRoom.memory.buildQueue[i].x == curCoord.x && curRoom.memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                }
                if (!isBadLoc) {
                    // Queue construction of tower
                    queueBuild(curCoord.x, curCoord.y, STRUCTURE_TOWER);
                    numTowersQueued++;
                    // Break loop on size cap
                    if (numTowers + numTowersQueued >= towerCap) {
                        break towerQueue;
                    }
                }
                
                // x - a, y - b
                curCoord = {x: spawnPos.x - a, y: spawnPos.y - b};
                // Check tile
                isBadLoc = false;
                // Check if tile is a wall
                if (Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == 'wall' || Game.map.getTerrainAt(curCoord.x, curCoord.y, curRoom.name) == ERR_NOT_IN_RANGE) {
                    isBadLoc = true;
                }
                else {
                    // Check if there are errors looking at the tile
                    if (curRoom.lookAt(curCoord.x, curCoord.y) < 0) {
                        isBadLoc = true;
                    }
                    else {
                        var tile = curRoom.lookAt(curCoord.x, curCoord.y);
                        tileCheck:
                        for (var i in tile) {
                            // Check if tile has a structure
                            if (tile[i].type == LOOK_STRUCTURES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                            // Check if tile has a construction site
                            if (tile[i].type == LOOK_CONSTRUCTION_SITES) {
                                isBadLoc = true;
                                break tileCheck;
                            }
                        }
                    }
                }
                // Check build queue
                if (curRoom.memory.buildQueue) {
                    buildQueueCheck:
                    for (var i in curRoom.memory.buildQueue) {
                        if (curRoom.memory.buildQueue[i].x == curCoord.x && curRoom.memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                }
                if (!isBadLoc) {
                    // Queue construction of tower
                    queueBuild(curCoord.x, curCoord.y, STRUCTURE_TOWER);
                    numTowersQueued++;
                    // Break loop on size cap
                    if (numTowers + numTowersQueued >= towerCap) {
                        break towerQueue;
                    }
                }
                
                a--;
            }
        }
        
        /*
        if (curRoom.controller.level >= 3 && extensions.length >= 5) {
            queueBuild(curSpawn.pos.x + 2,curSpawn.pos.y, STRUCTURE_TOWER);
        }
        
        if (curRoom.controller.level >= 5 && extensions.length >= 20) {
            queueBuild(curSpawn.pos.x,curSpawn.pos.y + 2, STRUCTURE_TOWER);
        }
        */
        
        if (numTowers && !curRoom.memory.sourceRoad[3]) {
            buildRoad(curRoom.findPath(spawns[0].pos,sources[2].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            curRoom.memory.sourceRoad[3] = true;
        }
        
        if (containers.length == 4) {
            queueBuild(containers[3].pos.x, containers[3].pos.y, STRUCTURE_RAMPART);
        }
        
        // Queue building of roads around extensions **IMPROVE THIS
        if (!(Game.time % 1000)) {
            for (let i in extensions) {
                queueBuild(extensions[i].pos.x + 1, extensions[i].pos.y, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x - 1, extensions[i].pos.y, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x, extensions[i].pos.y + 1, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x, extensions[i].pos.y - 1, STRUCTURE_ROAD);
            }
        }
        
        if (sites < MAXSITES && curRoom.memory.buildQueue[0]) {
            let site = curRoom.memory.buildQueue[0];
            curRoom.createConstructionSite(site.x, site.y, site.type)
            curRoom.memory.buildQueue.shift();
        }
    }
}

module.exports = maintainStructures;
