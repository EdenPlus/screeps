// This script allows for control over things through the console

/*
Description:
Visualizes the boundary of the nexus (Theorized to break once the source roads are added to the plan queue)

Parameters:
targetRoom - Room object

Usage:
require('commands').visualizeBoundary({Room object});

Example:
require('commands').visualizeBoundary(Game.rooms['sim']);
*/
function visualizeBoundary(targetRoom) {
    var firstSpawn = targetRoom.find(FIND_MY_SPAWNS)[0];
    var storageLoc = {x: (firstSpawn.pos.x - 1), y: firstSpawn.pos.y};
    var boundaries = {top: storageLoc.y, left: storageLoc.x, bottom: storageLoc.y, right: storageLoc.x};
    var planQueue = targetRoom.memory.plan.planQueue;
    for (var a in planQueue) {
        if (planQueue[a].type > 3) {
            if (planQueue[a].y < boundaries.top) {
                boundaries.top = planQueue[a].y;
            }
            else if (planQueue[a].y > boundaries.bottom) {
                boundaries.bottom = planQueue[a].y;
            }
            if (planQueue[a].x < boundaries.left) {
                boundaries.left = planQueue[a].x;
            }
            else if (planQueue[a].x > boundaries.right) {
                boundaries.right = planQueue[a].x;
            }
        }
    }
    var padding = 4;
    boundaries.top -= padding;
    boundaries.left -= padding;
    boundaries.bottom += padding;
    boundaries.right += padding;
    new RoomVisual(targetRoom.name).rect((boundaries.left - 0.5), (boundaries.top - 0.5), (boundaries.right - boundaries.left + 1), (boundaries.bottom - boundaries.top + 1), {fill: 'transparent', stroke: 'red'});
    return boundaries;
}

/*
Description:
Used to reset a section of the planning

Parameters:
roomPos - RoomPosition object
integer - An integer for the padding around the spot

Usage:
require('commands').drawArea({RoomPosition object}, integer);

Example:
require('commands').drawArea(Game.rooms['sim'].controller.pos, 4);
*/
function drawArea(roomPos, padding) {
    var top = roomPos.y - padding;
    var left = roomPos.x - padding;
    var bottom = roomPos.y + padding;
    var right = roomPos.x + padding;
    new RoomVisual(roomPos.name).rect((left - 0.5), (top - 0.5), (right - left + 1), (bottom - top + 1), {fill: 'transparent', stroke: 'red'});
}

/*
Description:
Used to reset a section of the planning

Parameters:
targetRoom - Room object
targetPlan - String (look to switch statement for the list)

Usage:
require('commands').resetPlan({Room object}, String);

Example:
require('commands').resetPlan(Game.rooms['sim'], 'ramparts');
*/
function resetPlan(targetRoom, targetPlan) {
    //    Road: 1        | D  Rampart: 2      |    Wall: 3         | D  Extension: 4
    // D  Tower: 5       | D  Spawn: 6        |    Power Spawn: 7  | D  Storage: 8
    //    Link: 9        | D  Lab: 10         | D  Terminal: 11    |    Observer: 12 
    //    Extractor: 13  | D  Container: 14
    switch(targetPlan) {
        case "extensions":
            return "Sorry, but that plan reset hasn't been made";
            break;
        case "core":
            return "Sorry, but that plan reset hasn't been made";
            break;
        case "labs":
            return "Sorry, but that plan reset hasn't been made";
            break;
        case "sourceRoads":
            return "Sorry, but that plan reset hasn't been made";
            break;
        case "towers":
            var temp = _.filter(targetRoom.memory.plan.planQueue, (schematic) => schematic.type != 5);
            targetRoom.memory.plan.planQueue = temp;
            targetRoom.memory.plan.towers = false;
            break;
        case "ramparts":
            var temp = _.filter(targetRoom.memory.plan.planQueue, (schematic) => schematic.type != 2);
            targetRoom.memory.plan.planQueue = temp;
            targetRoom.memory.plan.ramparts = false;
            break;
        default:
            return "Invalid planner type";
    }
}

/*
Description:
Shorthand for: Memory.tickSpeedReport = (true/false)

Parameters:
N/A

Usage:
require('commands').toggleTSR();

Example:
require('commands').toggleTSR();
*/
function toggleTSR() {
    if (Memory.tickSpeedReport == true) {
        Memory.tickSpeedReport = false;
    }
    else {
        Memory.tickSpeedReport = true;
    }
}

// Whenever a command is added to this script, it needs to be referenced in this export, following the already listed function's format
module.exports = {
    visualizeBoundary: visualizeBoundary,
    resetPlan: resetPlan,
    toggleTSR: toggleTSR,
    drawArea: drawArea
};
