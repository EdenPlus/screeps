var maintainCreeps = require('func.maintainCreeps');
var maintainStructures = require('func.maintainStructures');
var maintainNexus = require('func.maintainNexus');
var roleHarvester = require('role.harvester');
var roleBuilder = require('role.builder');
var roleUpgrader = require('role.upgrader');
var roleRepairer = require('role.repairer');
var roleMiner = require('role.miner');
var roleTransfer = require('role.transfer');
var roleFiller = require('role.filler');
var roleTower = require('role.tower');
var roleFighter = require('role.fighter');
var roleHealer = require('role.healer');

module.exports.loop = function () {
    // Status report start
    const TICKSTOREPORT = 10;
    
    if (!(Game.time % TICKSTOREPORT)) {
        // State report start
        console.log('  -=======  STATE REPORT  =======-   ');
        console.log('Star Date: '+Game.time);
        console.log('Work Status: '+Memory.status);
        // State report end
        
        // Controller report start
        console.log('  -=======  CONTROLLER REPORT  =======-   ');
        console.log('Controller Level: '+Game.rooms['sim'].controller.level);
        
        var progressBar = '[';
        var progressBarLength = 29;
        for (let x = 0; x < progressBarLength; x++) {
            if (x == Math.floor(progressBarLength/2)) {
                progressBar+=(Game.rooms['sim'].controller.progress/Game.rooms['sim'].controller.progressTotal * 100).toFixed(1)+'%';
            } else if (x/progressBarLength < Game.rooms['sim'].controller.progress/Game.rooms['sim'].controller.progressTotal) {
                progressBar+='=';
            } else {
                progressBar+=' ';
            }
        }
        progressBar += ']';
        
        console.log('Progess: '+Game.rooms['sim'].controller.progress+'/'+Game.rooms['sim'].controller.progressTotal+
//            ' = '+(Game.rooms['sim'].controller.progress/Game.rooms['sim'].controller.progressTotal * 100).toFixed(1)+'%' + 
            ' '+progressBar);
            
        if (Game.rooms['sim'].controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[Game.rooms['sim'].controller.level]) {
            console.log('Ticks to downgrade: '+Game.rooms['sim'].controller.ticksToDowngrade);
        }
        // Controller report end
        
        // Speed report start
        console.log('  -=======  SPEED REPORT  =======-   ');
        if (!Memory.seconds) Memory.seconds = 0;
        
        var seconds = new Date().getSeconds();
        
        if (0 > (seconds - Memory.seconds)) {
            console.log(seconds + 60 - Memory.seconds+' seconds since last update.');
            console.log('Speed: '+(TICKSTOREPORT / (seconds + 60 - Memory.seconds)).toFixed(2)+' ticks per second.');
            console.log('Speed: '+((seconds + 60 - Memory.seconds) / TICKSTOREPORT).toFixed(2)+' seconds per tick.');
        } else {
            console.log(seconds - Memory.seconds+' seconds since last update.');
            console.log('Speed: '+(TICKSTOREPORT / (seconds - Memory.seconds)).toFixed(2)+' ticks per second.');
            console.log('Speed: '+((seconds - Memory.seconds) / TICKSTOREPORT).toFixed(2)+' seconds per tick.');
        }
        
        Memory.seconds = seconds;
        // Speed report end
        
        // Repair report start
        if (!Memory.repairSites) Memory.repairSites = [];
        
        if (Memory.repairSites.length) {
            console.log('  -=======  REPAIR REPORT  =======-   ');
            console.log(Memory.repairSites.length+' structures are damaged.')
        }
        // Repair report end
        
        // Energy report start
        console.log('  -=======  ENERGY REPORT  =======-   ');
        console.log('Room Energy: '+Game.rooms['sim'].energyAvailable+'/'+Game.rooms['sim'].energyCapacityAvailable+' = '+
        Math.floor((Game.rooms['sim'].energyAvailable/Game.rooms['sim'].energyCapacityAvailable) * 100) // Percent
        +"%");
        
        var containers = Game.rooms['sim'].find(FIND_STRUCTURES, {
            filter: (structure) => {
                return structure.structureType == STRUCTURE_CONTAINER;
            }
        });
        
        if (containers.length) {
            if (Game.rooms['sim'].storage) {
                containers = containers.concat(Game.rooms['sim'].storage);
            }
            for (let x in containers) {
                console.log(containers[x]+' has '+containers[x].store.energy);
            }
        }
        // Energy report end
        
        // Nexus report start
        if (!Game.spawns['Spawn1'].memory.nexus) Game.spawns['Spawn1'].memory.nexus = [];
        if (Game.spawns['Spawn1'].memory.nexus.length) {
            console.log('  -=======  NEXUS REPORT  =======-   ');
            var temp = "Nexus Coords: ";
            for (var i in Game.spawns['Spawn1'].memory.nexus) {
                temp += "[" + Game.spawns['Spawn1'].memory.nexus[i].x + "," + Game.spawns['Spawn1'].memory.nexus[i].y + "] ";
            }
            console.log(temp);
            console.log("Extensions Built: " + Game.spawns['Spawn1'].room.find(STRUCTURE_EXTENSION).length + "/" + Game.spawns['Spawn1'].memory.nexus.length);
        }
        // Nexus report end
    }
    // Status Report end
    
    // Controller level up tick recorder start
    if (!Memory.levelTime) {
        Memory.levelTime = [];
    } else if (!Memory.levelTime[Game.rooms['sim'].controller.level]) {
        Memory.levelTime[Game.rooms['sim'].controller.level] =
            { level: Game.rooms['sim'].controller.level, time: Game.time}
    }
    // Controller level up tick recorder end
    
    // Maintenance start
    maintainCreeps.run();
    
    if (!(Game.time % 10)) {
        maintainNexus.run();
        maintainStructures.run();
    }
    // Maintenance end
    
    // Unit AI start
    var towers = Game.rooms['sim'].find(FIND_STRUCTURES, {
        filter: (structure) => {
            return structure.structureType == STRUCTURE_TOWER;
        }
    });
    
    for (let x in towers) {
        roleTower.run(towers[x]);
    }
    
    for (var name in Game.creeps) {
        var creep = Game.creeps[name];
        
//        creep.suicide();
        
        if (creep.memory.role == 'healer') {
            roleHealer.run(creep);
        }
        if (creep.memory.role == 'fighter') {
            delete creep.memory.job;
            roleFighter.run(creep);
        }
        if (creep.memory.role == 'harvester') {
//            creep.suicide();
            roleHarvester.run(creep);
        }
        if (creep.memory.role == 'builder') {
//            creep.suicide();
            roleBuilder.run(creep);
        }
        if (creep.memory.role == 'upgrader') {
            roleUpgrader.run(creep);
        }
        if (creep.memory.role == 'repairer') {
            roleRepairer.run(creep);
//            creep.memory.job = false;
        }
        if (creep.memory.role == 'miner') {
            //creep.suicide();
            roleMiner.run(creep);
        }
        if (creep.memory.role == 'transfer') {
//            delete creep.memory.job;
            roleTransfer.run(creep);
//            creep.suicide();
        }
        if (creep.memory.role == 'filler') {
//            delete creep.memory.job;
            roleFiller.run(creep);
        }
        if (creep.memory.role == 'test pilot') {
            creep.moveTo(0,25);
        }
    }
    // Unit AI end
}
