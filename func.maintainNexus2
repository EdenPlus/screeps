var maintainNexus = {
    
    run: function(curRoom) {
        var curSpawn = curRoom.find(FIND_MY_SPAWNS)[0];
        if (!curRoom.memory.plan && curRoom.memory.plan != false) curRoom.memory.plan = {};
        if (!curRoom.memory.plan.planQueue) curRoom.memory.plan.planQueue = [];
        if (!curRoom.memory.plan.offset) curRoom.memory.plan.offset = 1;
        if (!curRoom.memory.plan.isSorted) curRoom.memory.plan.isSorted = false;
        if (!curRoom.memory.plan.finale && curRoom.memory.plan.finale != false) curRoom.memory.plan.finale = false;
        if (!curRoom.memory.plan.NW && curRoom.memory.plan.NW != false) curRoom.memory.plan.NW = true;
        if (!curRoom.memory.plan.SW && curRoom.memory.plan.SW != false) curRoom.memory.plan.SW = true;
        if (!curRoom.memory.plan.NE && curRoom.memory.plan.NE != false) curRoom.memory.plan.NE = true;
        if (!curRoom.memory.plan.SE && curRoom.memory.plan.SE != false) curRoom.memory.plan.SE = true;
        
        function mapExtensions (roadPos, xA, xB, xC, yA, yB, yC) {
            var xShift = true;
            var yShift = true;
            if (xShift) {
                if(trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    if (Game.map.getTerrainAt(xA, roadPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: xA, y: roadPos.y, structureType: 1});
                        queuedInTick++;
                    }
                    else {
                        xShift = false;
                    }
                }
                else {
                    return;
                }
            }
            if (yShift) {
                if(trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    if (Game.map.getTerrainAt(roadPos.x, yA, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: roadPos.x, y: yA, structureType: 1});
                        queuedInTick++;
                    }
                    else {
                        yShift = false;
                    }
                }
                else {
                    return;
                }
            }
            if (!xShift && !yShift) {
                return;
            }
            if (xShift) {
                if(trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    if (Game.map.getTerrainAt(xB, roadPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: xB, y: roadPos.y, structureType: 1});
                        queuedInTick++;
                    }
                    else {
                        xShift = false;
                    }
                }
                else {
                    return;
                }
            }
            if (yShift) {
                if(trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    if (Game.map.getTerrainAt(roadPos.x, yB, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: roadPos.x, y: yB, structureType: 1});
                        queuedInTick++;
                    }
                    else {
                        yShift = false;
                    }
                }
                else {
                    return;
                }
            }
            if (!xShift && !yShift) {
                return;
            }
            if (xShift) {
                if(trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    if (Game.map.getTerrainAt(xC, roadPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: xC, y: roadPos.y, structureType: 0});
                        queuedInTick++;
                    }
                    else {
                        xShift = false;
                    }
                }
                else {
                    return;
                }
            }
            if (yShift) {
                if(trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    if (Game.map.getTerrainAt(roadPos.x, yC, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: roadPos.x, y: yC, structureType: 0});
                        queuedInTick++;
                    }
                    else {
                        yShift = false;
                    }
                }
                else {
                    return
                }
            }
            if (!xShift && !yShift) {
                return;
            }
        }
        
        if (curRoom.memory.plan) {
            var trial = _.filter(curRoom.memory.plan.planQueue, (schematic) => schematic.structureType == 1);
            var trial2 = _.filter(curRoom.memory.buildQueue, (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
            var trial3 = _.filter(curRoom.find(FIND_STRUCTURES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
            var trial4 = _.filter(curRoom.find(FIND_CONSTRUCTION_SITES), (schematic) => schematic.structureType == STRUCTURE_EXTENSION);
            var maxExtensions = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION]["8"];
            var queuedInTick = 0;
            
            if (curRoom.memory.plan.NW) {
                if (trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    var curPos = {x: (curSpawn.pos.x - curRoom.memory.plan.offset), y: (curSpawn.pos.y - curRoom.memory.plan.offset)};
                    if (Game.map.getTerrainAt(curPos.x, curPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: curPos.x, y: curPos.y, structureType: 0});
                        mapExtensions(curPos, (curPos.x - 1), (curPos.x - 2), (curPos.x - 3), (curPos.y - 1), (curPos.y - 2), (curPos.y - 3));
                    }
                    else {
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset), y: (curSpawn.pos.y - curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 1), y: (curSpawn.pos.y - curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 1), structureType: 0});
                        curRoom.memory.plan.NW = false;
                    }
                }
                else {
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 1), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 2), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 1), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 2), structureType: 0});
                    curRoom.memory.plan.NW = false;
                }
            }
            if (curRoom.memory.plan.SW) {
                if (trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    var curPos = {x: (curSpawn.pos.x - curRoom.memory.plan.offset), y: (curSpawn.pos.y + curRoom.memory.plan.offset)};
                    if (Game.map.getTerrainAt(curPos.x, curPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: curPos.x, y: curPos.y, structureType: 0});
                        mapExtensions(curPos, (curPos.x - 1), (curPos.x - 2), (curPos.x - 3), (curPos.y + 1), (curPos.y + 2), (curPos.y + 3));
                    }
                    else {
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset), y: (curSpawn.pos.y + curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 1), y: (curSpawn.pos.y + curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 1), structureType: 0});
                        curRoom.memory.plan.SW = false;
                    }
                }
                else {
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 1), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 2), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - curRoom.memory.plan.offset - 1), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 2), structureType: 0});
                    curRoom.memory.plan.SW = false;
                }
            }
            if (curRoom.memory.plan.NE) {
                if (trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    var curPos = {x: (curSpawn.pos.x + curRoom.memory.plan.offset), y: (curSpawn.pos.y - curRoom.memory.plan.offset)};
                    if (Game.map.getTerrainAt(curPos.x, curPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: curPos.x, y: curPos.y, structureType: 0});
                        mapExtensions(curPos, (curPos.x + 1), (curPos.x + 2), (curPos.x + 3), (curPos.y - 1), (curPos.y - 2), (curPos.y - 3));
                    }
                    else {
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset), y: (curSpawn.pos.y - curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 1), y: (curSpawn.pos.y - curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 1), structureType: 0});
                        curRoom.memory.plan.NE = false;
                    }
                }
                else {
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 1), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 2), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 1), y: (curSpawn.pos.y - curRoom.memory.plan.offset - 2), structureType: 0});
                    curRoom.memory.plan.NE = false;
                }
            }
            if (curRoom.memory.plan.SE) {
                if (trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                    var curPos = {x: (curSpawn.pos.x + curRoom.memory.plan.offset), y: (curSpawn.pos.y + curRoom.memory.plan.offset)};
                    if (Game.map.getTerrainAt(curPos.x, curPos.y, curRoom.name) !== 'wall') {
                        curRoom.memory.plan.planQueue.push({x: curPos.x, y: curPos.y, structureType: 0});
                        mapExtensions(curPos, (curPos.x + 1), (curPos.x + 2), (curPos.x + 3), (curPos.y + 1), (curPos.y + 2), (curPos.y + 3));
                    }
                    else {
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset), y: (curSpawn.pos.y + curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 1), y: (curSpawn.pos.y + curRoom.memory.plan.offset), structureType: 0});
                        curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 1), structureType: 0});
                        curRoom.memory.plan.SE = false;
                    }
                }
                else {
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 1), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 2), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 1), structureType: 0});
                    curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + curRoom.memory.plan.offset + 1), y: (curSpawn.pos.y + curRoom.memory.plan.offset + 2), structureType: 0});
                    curRoom.memory.plan.SE = false;
                }
            }
            if (trial.length + trial2.length + trial3.length + trial4.length + queuedInTick < maxExtensions) {
                curRoom.memory.plan.offset++;
            }
            else if (!curRoom.memory.plan.finale) {
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - 1), y: (curSpawn.pos.y), structureType: 4});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - 2), y: (curSpawn.pos.y), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x - 3), y: (curSpawn.pos.y), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + 1), y: (curSpawn.pos.y), structureType: 2});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + 2), y: (curSpawn.pos.y), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x + 3), y: (curSpawn.pos.y), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x), y: (curSpawn.pos.y - 1), structureType: 3});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x), y: (curSpawn.pos.y - 2), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x), y: (curSpawn.pos.y - 3), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x), y: (curSpawn.pos.y + 1), structureType: 2});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x), y: (curSpawn.pos.y + 2), structureType: 0});
                curRoom.memory.plan.planQueue.push({x: (curSpawn.pos.x), y: (curSpawn.pos.y + 3), structureType: 0});
                /*
                var sorted = curRoom.memory.plan.planQueue.slice(0);
                sorted.sort(function(a,b) {
                    return a.x - b.x;
                });
                sorted.sort(function(a,b) {
                    var x = a.structureType;
                    var y = b.structureType;
                    return x < y ? -1 : x > y ? 1 : 0;
                });
                curRoom.memory.plan.planQueue = sorted;
                */
                curRoom.memory.plan.finale = true;
            }
            else if (curRoom.memory.plan.planQueue.length == 0) {
                curRoom.memory.plan = false;
            }
            queuedInTick = 0;
        }
    }
}

module.exports = maintainNexus;
