var maintainNexus = {
    
    run: function() {
        // Stuff pulled from func.maintainStructures
        const MAXSITES = 3;
        
        var spawns = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_SPAWN);
        var extensions = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_EXTENSION);
        var containers = Game.rooms['sim'].find(FIND_STRUCTURES, {
            filter: (structure) => {
                return structure.structureType == STRUCTURE_CONTAINER;
            }
        });
        var sources = Game.rooms['sim'].find(FIND_SOURCES);
        
        Memory.constructionSites = Game.rooms['sim'].find(FIND_CONSTRUCTION_SITES);
        var sites =  Memory.constructionSites.length;
        
        var numFighters = _.filter(Game.creeps, (creep) => creep.memory.role == 'fighter').length;
        var numHealers = _.filter(Game.creeps, (creep) => creep.memory.role == 'healer').length;
        var numTowers = _.filter(Game.structures, (structure) => structure.structureType == STRUCTURE_TOWER).length;
        
        // function for determining the location of the next extension
        function getNextSite() {
            return new RoomPosition(spawns[0].pos.x - 1, spawns[0].pos.y + 1, spawns[0].pos.roomName);
        }
        
        if (!Memory.repairSites) {
            Memory.repairSites = [];
        }
        
        if (!(Game.time % 100) && !sites) {
             var repairSites = Game.rooms['sim'].find(FIND_STRUCTURES, {
                filter: (structure) => {
                    if (Game.rooms['sim'].find(FIND_HOSTILE_CREEPS).length) {
                        return (structure.hits < (structure.hitsMax * .5) && structure.structureType != STRUCTURE_RAMPART);
                    } else {
                        return (structure.hits < (structure.hitsMax * .5) && structure.structureType != STRUCTURE_RAMPART); //  Fix anything below %
                    }
                }
            });
            
            Memory.repairSites = [];
            
            for (let i in repairSites) {
                Memory.repairSites[i] = repairSites[i].id;
            }
            
        }
        
        if (!Memory.sourceRoad) {
            Memory.sourceRoad = [];
        }
        
        if (extensions.length == 5 && !Memory.sourceRoad[0]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[0].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            queueBuild(spawns[0].pos.x + 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x - 1, spawns[0].pos.y, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y + 1, STRUCTURE_ROAD);
            queueBuild(spawns[0].pos.x, spawns[0].pos.y - 1, STRUCTURE_ROAD);
            Memory.sourceRoad[0] = true;
        }
        
        if (containers.length == 1 && !Memory.sourceRoad[1]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[1].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            Memory.sourceRoad[1] = true;
        }
        
        if (containers.length == 2 && !Memory.sourceRoad[2]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[3].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            buildControllerRoad();
            Memory.sourceRoad[2] = true;
        }
        
        if (numTowers && !Memory.sourceRoad[3]) {
            buildRoad(Game.rooms['sim'].findPath(spawns[0].pos,sources[2].pos, {ignoreCreeps: true}), STRUCTURE_CONTAINER);
            Memory.sourceRoad[3] = true;
        }
        
        if (containers.length == 4) {
            queueBuild(containers[3].pos.x, containers[3].pos.y, STRUCTURE_RAMPART);
        }
        
        // queue building of roads around extensions **IMPROVE THIS
        if (!(Game.time % 1000)) {
            for (let i in extensions) {
                queueBuild(extensions[i].pos.x + 1, extensions[i].pos.y, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x - 1, extensions[i].pos.y, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x, extensions[i].pos.y + 1, STRUCTURE_ROAD);
                queueBuild(extensions[i].pos.x, extensions[i].pos.y - 1, STRUCTURE_ROAD);
            }
        }
        
        if (sites < MAXSITES && Memory.buildQueue[0]) {
            let site = Memory.buildQueue[0];
//            console.log('Adding ',site.x, site.y, site.type);
//            console.log(Game.rooms['sim'].createConstructionSite(site.x, site.y, site.type));
            Game.rooms['sim'].createConstructionSite(site.x, site.y, site.type)
            Memory.buildQueue.shift();
//            console.log(Memory.buildQueue.length, ' items left in queue.');
        }
        // function to add new construction sites to a list for building
        function queueBuild(x, y, type) {
            
            if (!Memory.buildQueue) {
                Memory.buildQueue = []
            }
            
            for (let i in Memory.buildQueue) {
                if (x == Memory.buildQueue[i].x && y == Memory.buildQueue[i].y) {
                    return -1;
                }
            }
            
            if ((!Game.rooms['sim'].lookForAt(LOOK_STRUCTURES,x,y)[0]) || type == STRUCTURE_RAMPART) {
                Memory.buildQueue.push({x:x,y:y,type:type});
            }
        }
        
        // queues up construction for a path
        function buildRoad(path, end) {
            
            for (let i in path) {
//                console.log('i is '+i);
                
                //build the road and container at the end
                if (i < (path.length - 2)) {
//                    console.log('Building road at ('+path[i].x+','+path[i].y+').');
                    queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
                } else {
                    queueBuild(path[i].x,path[i].y, end);
                }
            }
        }
        
        function buildControllerRoad() {
            
            var path = Game.rooms['sim'].findPath(spawns[0].pos,Game.rooms['sim'].controller.pos, {ignoreCreeps: true});
            
            for (let i = 0; i < (path.length - 5); i++) {
                queueBuild(path[i].x,path[i].y, STRUCTURE_ROAD);
            }
            
            for (let i = -3; i <= 3; i++) {
                queueBuild(Game.rooms['sim'].controller.pos.x + i, Game.rooms['sim'].controller.pos.y + 4, STRUCTURE_ROAD);
            }
            
            for (let i = 3; i >= -3; i--) {
                queueBuild(Game.rooms['sim'].controller.pos.x - 4, Game.rooms['sim'].controller.pos.y + i, STRUCTURE_ROAD);
            }
            
            for (let i = 3; i >= -3; i--) {
                queueBuild(Game.rooms['sim'].controller.pos.x + 4, Game.rooms['sim'].controller.pos.y + i, STRUCTURE_ROAD);
            }
            
            for (let i = -3; i <= 3; i++) {
                queueBuild(Game.rooms['sim'].controller.pos.x + i, Game.rooms['sim'].controller.pos.y - 4, STRUCTURE_ROAD);
            }
            
        }
        // End of stuff pulled from func.maintainStructures
        if (!Game.spawns['Spawn1'].memory.nexus) Game.spawns['Spawn1'].memory.nexus = [];
        if (!Game.spawns['Spawn1'].memory.nexusSize) Game.spawns['Spawn1'].memory.nexusSize = 4;
        if (!Memory.buildQueue) Memory.buildQueue = [];
        
        let extensionCount = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][Game.rooms['sim'].controller.level];
        let spawnPos = Game.spawns['Spawn1'].pos;
        
        fillNexusMap:
        while (Game.spawns['Spawn1'].memory.nexus.length < extensionCount) {
            let a = Game.spawns['Spawn1'].memory.nexusSize;
            while (a >= 0) {
                let b = Game.spawns['Spawn1'].memory.nexusSize - a;
                var curCoord = {x: spawnPos.x + a, y: spawnPos.y + b};
                var isDupe = false;
                // Check if coordinate is dupe
                for (var i in Game.spawns['Spawn1'].memory.nexus) {
                    if (Game.spawns['Spawn1'].memory.nexus[i].x == curCoord.x && Game.spawns['Spawn1'].memory.nexus[i].y == curCoord.y) isDupe = true;
                }
                // Validate if not dupe
                if (!isDupe) {
                    // Check tile
                    var isBadLoc = false;
                    var tile = Game.spawns['Spawn1'].room.lookAt(curCoord.x, curCoord.y);
                    tileCheck:
                    for (var i in tile) {
                        if (tile[i][0] == 'structure') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][0] == 'constructionSite') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][1] == 'wall') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                    }
                    // Check build queue
                    buildQueueCheck:
                    for (var i in Memory.buildQueue) {
                        if (Memory.buildQueue[i].x == curCoord.x && Memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                    if (!isBadLoc) 
                        // Add coordinate to nexus
                        Game.spawns['Spawn1'].memory.nexus.push({x: curCoord.x, y: curCoord.y});
                        // Break loop on size cap
                        if (Game.spawns['Spawn1'].memory.nexus.length >= extensionCount) break fillNexusMap;
                    }
                }
                
                curCoord = {x: spawnPos.x + a, y: spawnPos.y - b};
                isDupe = false;
                // Check if coordinate is dupe
                for (var i in Game.spawns['Spawn1'].memory.nexus) {
                    if (Game.spawns['Spawn1'].memory.nexus[i].x == curCoord.x && Game.spawns['Spawn1'].memory.nexus[i].y == curCoord.y) isDupe = true;
                }
                // Validate if not dupe
                if (!isDupe) {
                    // Check tile
                    var isBadLoc = false;
                    var tile = Game.spawns['Spawn1'].room.lookAt(curCoord.x, curCoord.y);
                    tileCheck:
                    for (var i in tile) {
                        if (tile[i][0] == 'structure') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][0] == 'constructionSite') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][1] == 'wall') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                    }
                    // Check build queue
                    buildQueueCheck:
                    for (var i in Memory.buildQueue) {
                        if (Memory.buildQueue[i].x == curCoord.x && Memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                    if (isBadLoc) {
                        console.log('The tile at: [' + curCoord.x + ',' + curCoord.y + '] is a bad tile, recalculating...');
                    }
                    else {
                        // Add coordinate to nexus
                        Game.spawns['Spawn1'].memory.nexus.push({x: curCoord.x, y: curCoord.y});
                        // Break loop on size cap
                        if (Game.spawns['Spawn1'].memory.nexus.length >= extensionCount) break fillNexusMap;
                    }
                }
                
                curCoord = {x: spawnPos.x - a, y: spawnPos.y + b};
                isDupe = false;
                // Check if coordinate is dupe
                for (var i in Game.spawns['Spawn1'].memory.nexus) {
                    if (Game.spawns['Spawn1'].memory.nexus[i].x == curCoord.x && Game.spawns['Spawn1'].memory.nexus[i].y == curCoord.y) isDupe = true;
                }
                // Validate if not dupe
                if (!isDupe) {
                    // Check tile
                    var isBadLoc = false;
                    var tile = Game.spawns['Spawn1'].room.lookAt(curCoord.x, curCoord.y);
                    tileCheck:
                    for (var i in tile) {
                        if (tile[i][0] == 'structure') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][0] == 'constructionSite') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][1] == 'wall') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                    }
                    // Check build queue
                    buildQueueCheck:
                    for (var i in Memory.buildQueue) {
                        if (Memory.buildQueue[i].x == curCoord.x && Memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                    if (isBadLoc) {
                        console.log('The tile at: [' + curCoord.x + ',' + curCoord.y + '] is a bad tile, recalculating...');
                    }
                    else {
                        // Add coordinate to nexus
                        Game.spawns['Spawn1'].memory.nexus.push({x: curCoord.x, y: curCoord.y});
                        // Break loop on size cap
                        if (Game.spawns['Spawn1'].memory.nexus.length >= extensionCount) break fillNexusMap;
                    }
                }
                
                curCoord = {x: spawnPos.x - a, y: spawnPos.y - b};
                isDupe = false;
                // Check if coordinate is dupe
                for (var i in Game.spawns['Spawn1'].memory.nexus) {
                    if (Game.spawns['Spawn1'].memory.nexus[i].x == curCoord.x && Game.spawns['Spawn1'].memory.nexus[i].y == curCoord.y) isDupe = true;
                }
                // Validate if not dupe
                if (!isDupe) {
                    // Check tile
                    var isBadLoc = false;
                    var tile = Game.spawns['Spawn1'].room.lookAt(curCoord.x, curCoord.y);
                    tileCheck:
                    for (var i in tile) {
                        if (tile[i][0] == 'structure') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][0] == 'constructionSite') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                        if (tile[i][1] == 'wall') {
                            isBadLoc = true;
                            break tileCheck;
                        }
                    }
                    // Check build queue
                    buildQueueCheck:
                    for (var i in Memory.buildQueue) {
                        if (Memory.buildQueue[i].x == curCoord.x && Memory.buildQueue[i].y == curCoord.y) {
                            isBadLoc = true;
                            break buildQueueCheck;
                        }
                    }
                    if (isBadLoc) {
                        console.log('The tile at: [' + curCoord.x + ',' + curCoord.y + '] is a bad tile, recalculating...');
                    }
                    else {
                        // Add coordinate to nexus
                        Game.spawns['Spawn1'].memory.nexus.push({x: curCoord.x, y: curCoord.y});
                        // Break loop on size cap
                        if (Game.spawns['Spawn1'].memory.nexus.length >= extensionCount) break fillNexusMap;
                    }
                }
                
                a--;
            }
            if (Game.spawns['Spawn1'].memory.nexus.length <= extensionCount) Game.spawns['Spawn1'].memory.nexusSize += 2;
        }
    }
}

module.exports = maintainNexus;
